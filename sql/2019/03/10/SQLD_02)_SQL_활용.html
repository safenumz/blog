<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[SQLD] 02) SQL 활용 | Dev Log of Jason Ahn</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="[SQLD] 02) SQL 활용" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="POINT 1. 조인(JOIN) 1. EQUI(등가) 조인(교집합) (1) EQUI(등가) 조인 두 개의 테이블 간의 교집합을 구함 ’=’의 비교 연산자를 이용 ISO 표준 SQL로 INNER JOIN을 사용해야 함" />
<meta property="og:description" content="POINT 1. 조인(JOIN) 1. EQUI(등가) 조인(교집합) (1) EQUI(등가) 조인 두 개의 테이블 간의 교집합을 구함 ’=’의 비교 연산자를 이용 ISO 표준 SQL로 INNER JOIN을 사용해야 함" />
<link rel="canonical" href="https://safenumz.github.io/blog/sql/2019/03/10/SQLD_02)_SQL_%ED%99%9C%EC%9A%A9.html" />
<meta property="og:url" content="https://safenumz.github.io/blog/sql/2019/03/10/SQLD_02)_SQL_%ED%99%9C%EC%9A%A9.html" />
<meta property="og:site_name" content="Dev Log of Jason Ahn" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-10T00:00:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="[SQLD] 02) SQL 활용" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-03-10T00:00:00-06:00","datePublished":"2019-03-10T00:00:00-06:00","description":"POINT 1. 조인(JOIN) 1. EQUI(등가) 조인(교집합) (1) EQUI(등가) 조인 두 개의 테이블 간의 교집합을 구함 ’=’의 비교 연산자를 이용 ISO 표준 SQL로 INNER JOIN을 사용해야 함","headline":"[SQLD] 02) SQL 활용","mainEntityOfPage":{"@type":"WebPage","@id":"https://safenumz.github.io/blog/sql/2019/03/10/SQLD_02)_SQL_%ED%99%9C%EC%9A%A9.html"},"url":"https://safenumz.github.io/blog/sql/2019/03/10/SQLD_02)_SQL_%ED%99%9C%EC%9A%A9.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://safenumz.github.io/blog/feed.xml" title="Dev Log of Jason Ahn" /><link rel="shortcut icon" type="image/x-icon" href="/blog/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Dev Log of Jason Ahn</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About Me</a><a class="page-link" href="/blog/search/">Search</a><a class="page-link" href="/blog/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">[SQLD] 02) SQL 활용</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2019-03-10T00:00:00-06:00" itemprop="datePublished">
        Mar 10, 2019
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      14 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#SQL">SQL</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="point-1-조인join">POINT 1. 조인(JOIN)</h1>
<h2 id="1-equi등가-조인교집합">1. EQUI(등가) 조인(교집합)</h2>
<h3 id="1-equi등가-조인">(1) EQUI(등가) 조인</h3>
<ul>
  <li>두 개의 테이블 간의 교집합을 구함</li>
  <li>’=’의 비교 연산자를 이용</li>
  <li>ISO 표준 SQL로 INNER JOIN을 사용해야 함</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">,</span> <span class="n">DEPT</span>
<span class="k">WHERE</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span><span class="p">;</span>

<span class="c1">-- 조인문에 추가조건 및 정렬을 할 수 있음</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">,</span> <span class="n">DEPT</span>
<span class="k">WHERE</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span>
<span class="k">AND</span> <span class="n">EMP</span><span class="p">.</span><span class="n">ENAME</span> <span class="k">LIKE</span> <span class="s1">'임%'</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ENAME</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="2-inner-join">(2) INNER JOIN</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">DEPT</span>
<span class="k">ON</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="3-intersect-연산">(3) INTERSECT 연산</h3>
<ul>
  <li>INTERSECT 연산은 두 개의 테이블에서 교집합을 조회</li>
  <li>즉, 두 개 테이블에서 공통된 값을 조회</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- INTERSECT 연산은 두 개의 테이블에서 교집합을 조회</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">INTERSECT</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">DEPT</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="2-non-equi비등가-조인">2. Non-EQUI(비등가) 조인</h2>
<ul>
  <li>두 개의 테이블간의 조인하는 경우 ‘=’을 사용하지 않고 ‘&gt;’, ‘&lt;’, ‘&lt;=’ 등을 사용</li>
  <li>정확하게 일치하지 않는 것을 조회</li>
</ul>

<h2 id="3-outer-join">3. OUTER JOIN</h2>
<ul>
  <li>Outer join은 두 개의 테이블 간의 교집합을 조회하고 한쪽 테이블에만 있는 데이터도 포함시켜서 조회</li>
  <li>왼쪽 테이블에만 있는 행도 포함하면 Left Outer Join이라 하고 오른쪽 테이블의 행만 포함시키면 Right Outer Join이라 함</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- (+) : Oracle 데이터베이스 Outer join 방식</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">DEPT</span><span class="p">,</span> <span class="n">EMP</span>
<span class="k">WHERE</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="1-left-outer-join과-right-outer-join">(1) LEFT OUTER JOIN과 RIGHT OUTER JOIN</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">DEPT</span> <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">EMP</span>
<span class="k">ON</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">DEPT</span> <span class="k">RIGHT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">EMP</span>
<span class="k">ON</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="4-cross-join">4. CROSS JOIN</h2>
<ul>
  <li>CROSS JOIN은 조인 조건 구 없이 2개의 테이블을 하나로 조인함</li>
  <li>조인구가 없기 때문에 카테시안 곱이 발생</li>
  <li>예를 들어 행이 14개 있는 테이블과 행이 4개 있는 테이블을 조인하면 56개의 행이 조회</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">DEPT</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="5-union을-사용한-합집합-구현">5. UNION을 사용한 합집합 구현</h2>
<h3 id="1-union">(1) UNION</h3>
<ul>
  <li>두개의 테이블을 하나로 합치는 것인데, 두개의 테이블의 칼럼 수, 칼럼의 데이터 형식 모두가 일치해야 함, 칼럼 수가 다르면 오류가 발생</li>
  <li>UNION 연산은 두개의 테이블을 하나로 합치면서 중복된 데이터를 제거함</li>
  <li>그래서 UNION 연산은 정렬(SORT) 과정을 발생시킴</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">UNION</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="2-union-all">(2) UNION ALL</h3>
<ul>
  <li>두 개의 테이블을 하나로 합치는 것, 중복을 제거하거나 정렬을 유발하지 않음</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 중복을 제거하지 않고 단순하게 테이블을 합침</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="6-차집합을-만드는-minus">6. 차집합을 만드는 MINUS</h2>
<ul>
  <li>MS-SQL에서는 MINUS와 동일한 연산이 EXCEPT임</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">DEPT</span>
<span class="n">MINUS</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>
<h1 id="point-2-계층형-조회connect-by"><a href="">POINT 2. 계층형 조회(Connect by)</a></h1>
<ul>
  <li>계층형 조회는 Oracle 데이터베이스에서 지원하는 것으로 계층형으로 데이터를 조회할 수 있음</li>
  <li>즉, 상위 부장에서 차장, 차장에서 과장, 과장에서 대리, 대리에서 사원 순으로 트리형태의 구조를 탐색하면서 조회하는 것, 역방향도 가능함</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 계층형 조회 테스트 데이터 입력</span>
<span class="k">Create</span> <span class="k">table</span> <span class="n">EMP</span><span class="p">(</span>
  <span class="n">empno</span> <span class="n">number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
  <span class="n">ename</span> <span class="n">varchar2</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
  <span class="n">deptno</span> <span class="n">number</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
  <span class="n">mgr</span> <span class="n">number</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
  <span class="n">job</span> <span class="n">varchar2</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
  <span class="n">sal</span> <span class="n">number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">insert</span> <span class="k">into</span> <span class="n">EMP</span> <span class="k">values</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="s1">'test1'</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="k">NULL</span><span class="p">,</span> <span class="s1">'CLERK'</span><span class="p">,</span> <span class="mi">800</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">EMP</span> <span class="k">values</span><span class="p">(</span><span class="mi">1001</span><span class="p">,</span> <span class="s1">'test2'</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="s1">'SALESMAN'</span><span class="p">,</span> <span class="mi">1600</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">EMP</span> <span class="k">values</span><span class="p">(</span><span class="mi">1002</span><span class="p">,</span> <span class="s1">'test3'</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="s1">'SALESMAN'</span><span class="p">,</span> <span class="mi">1250</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">EMP</span> <span class="k">values</span><span class="p">(</span><span class="mi">1003</span><span class="p">,</span> <span class="s1">'test4'</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="s1">'MANAGER'</span><span class="p">,</span> <span class="mi">2975</span><span class="p">);</span>

</code></pre></div></div>

<ul>
  <li>Connect by는 트리(tree) 형태의 구조로 질의를 수행하는 것으로 START WITH구는 시작 조건을 의미하고 CONNECT BY PRIOR는 조인조건임, ROOT 노드로부터 하위 노드의 질의를 실행</li>
  <li>계층형 조회에서 최대 계층의 수를 구하기 위한 문제, MAX(LEVEL)을 사용하여 최대 계층 수를 구함, 즉, 계층형 구조에서 마지막 Leaf Node의 계층 값을 구함</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 최대 계층 값 출력</span>
<span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="k">LEVEL</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">Limbest</span><span class="p">.</span><span class="n">EMP</span>
<span class="k">START</span> <span class="k">WITH</span> <span class="n">MGR</span> <span class="k">IS</span> <span class="k">NULL</span>
<span class="k">CONNECT</span> <span class="k">BY</span> <span class="k">PRIOR</span> <span class="n">EMPNO</span> <span class="o">=</span> <span class="n">MGR</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>위의 SQL에서 MAX(LEVEL)이 4이므로 트리의 최대 깊이가 4임</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Connect by 구조</span>
<span class="k">SELECT</span> <span class="k">LEVEL</span><span class="p">,</span> <span class="n">EMPNO</span><span class="p">,</span> <span class="n">MGR</span><span class="p">,</span> <span class="n">ENAME</span>
<span class="k">FROM</span> <span class="n">Limbest</span><span class="p">.</span><span class="n">EMP</span>
<span class="k">START</span> <span class="k">WITH</span> <span class="n">MGR</span> <span class="k">IS</span> <span class="k">NULL</span>
<span class="k">CONNECT</span> <span class="k">BY</span> <span class="k">PRIOR</span> <span class="n">EMPNO</span> <span class="o">=</span> <span class="n">MGR</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>위에 예에서 EMPNO와 MGR 칼럼 모두 사원번호가 입력되어 있음</li>
  <li>하지만 MGR은 관리자 사원번호를 가지고 있음, 즉, MGR 1000번은 1001과 1002의 사원을 관리</li>
  <li>계층형 조회 결과를 명확히 보기 위해 LPAD 함수를 사용함</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Connect by 실행</span>
<span class="k">SELECT</span> <span class="k">LEVEL</span><span class="p">,</span> <span class="n">LPAD</span><span class="p">(</span><span class="s1">' '</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="k">LEVEL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="o">||</span> <span class="n">EMPNO</span><span class="p">,</span>
<span class="n">MGR</span><span class="p">,</span> <span class="n">CONNECT_BY_ISLEAF</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">START</span> <span class="k">WITH</span> <span class="n">MGR</span> <span class="k">IS</span> <span class="k">NULL</span>
<span class="k">CONNECT</span> <span class="k">BY</span> <span class="k">PRIOR</span> <span class="n">EMPNO</span> <span class="o">=</span> <span class="n">MGR</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>위의 예를 보면 4<em>LEVEL-1이 있음, LEVEL값은 Root이면 1이 됨, 따라서 4</em>(1-1)=0이 됨</li>
  <li>즉, Root일 때는 LPAD(‘ ‘,0)이므로 아무 의미가 없음</li>
  <li>하지만, LEVEL값이 2가 되면 4*(2-1)=4가 됨, LPAD(‘ ‘, 4)이므로 왼쪽 공백 4칸을 화면에 찍음</li>
  <li>결과적으로 LPAD는 트리 형태로 보기 위해 사용한 것</li>
  <li>왜냐하면 LEVEL값은 Root에 1을 되돌리고 그다음 자식은 2, 그리고 그다음 자식은 3이 나오기 때문</li>
</ul>

<h4 id="connect-by-키워드">CONNECT BY 키워드</h4>
<ul>
  <li>LEVEL : 검색 항목의 깊이를 의미, 즉, 계층구조에서 가장 상위 레벨이 1이 됨</li>
  <li>CONNECT_BY_ROOT : 계층 구조에서 가장 최상위 값을 표시</li>
  <li>CONNECT_BY_ISLEAF : 계층 구조에서 가장 최하위를 표시</li>
  <li>SYS_CONNECT_BY_PATH : 계층 구조의 전체 전개 경로를 표시</li>
  <li>NOCYCLE : 순환 구조가 발생지점까지만 전개</li>
  <li>CONNECT_BY_ISCYCLE : 순환 구조 발생 지점을 표시</li>
</ul>

<p><br /></p>
<h1 id="point-3-서브쿼리subquery"><a href="">POINT 3. 서브쿼리(Subquery)</a></h1>
<h2 id="1-main-query와-subquery">1. Main query와 Subquery</h2>
<ul>
  <li>Subquery의 형태는 FROM구에 SELECT문을 사용하는 인라인 뷰(VIEW)와 SELECT문에 Subquery를 사용하는 스칼라 서브쿼리 (Scala Subquery) 등이 있음</li>
  <li>WHERE구에 SELECT문을 사용하면 서브쿼리(Subquery)라고 함</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Subquery</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">WHERE</span> <span class="n">DEPTNO</span> <span class="o">=</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">DEPT</span>
<span class="k">WHERE</span> <span class="n">DEPTNO</span><span class="o">=</span><span class="mi">10</span><span class="p">);</span>

<span class="c1">-- FROM구에 있는 SELECT문을 인라인뷰(Inline view)라고 함</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">ROWNUM</span> <span class="n">NUM</span><span class="p">,</span> <span class="n">ENAME</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">)</span> <span class="n">a</span>
<span class="k">WHERE</span> <span class="n">NUM</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="2-단일-행-subquery와-다중-행-subquery">2. 단일 행 Subquery와 다중 행 Subquery</h2>
<ul>
  <li>서브쿼리(Subquery)는 반환하는 행 수가 한 개인 것과 여러 개인 것에 따라서 단일 행 서브쿼리와 멀티 행 서브쿼리로 분류</li>
  <li>단일 행 서브쿼리는 단 하나의 행만 반환하는 서브쿼리로 비교 연산자를 사용함</li>
  <li>다중 행 서브쿼리는 여러 개의 행을 반환하는 것으로 IN, ANY, ALL, EXISTS를 사용해야 함</li>
</ul>

<h3 id="서브쿼리-종류반환행">서브쿼리 종류(반환행)</h3>
<ul>
  <li>단일 행 서브쿼리(Single row subquery): 서브쿼리를 실행하면 그 결과는 한 행만 조회, 비교연산자(‘=’, ‘&lt;’, ‘&gt;’, ‘&gt;=’, ‘&lt;=’, ‘&lt;&gt;’)를 이용</li>
  <li>다중 행 서브쿼리(Multi row subquery) : 서브쿼리를 실행하면 그 결과는 여러 개의 행이 조회, 다중 행 비교 연산자인 IN, ANY, ALL, EXSITS를 사용</li>
</ul>

<h2 id="3-다중-행multi-row-subquery">3. 다중 행(Multi row) Subquery</h2>
<ul>
  <li>다중 행 서브쿼리(Multi row Subquery)는 서브쿼리 결과가 여러 개의 행을 반환하는 것으로 다중 행 연산자를 사용</li>
</ul>

<h3 id="다중-행-비교-연산자">다중 행 비교 연산자</h3>
<ul>
  <li>IN(Subquery) : Main query의 비교 조건이 Subquery의 결과 중 하나만 동일하면 참이 됨(OR 조건)</li>
  <li>ALL(Subquery) : Main query의 Subquery의 결과가 모두 동일하면 참이 됨, ‘&lt; ALL’(최소값을 반환), ‘&gt; ALL’(최대값을 반환)</li>
  <li>ANY(Subquery) : Main query의 비교조건이 Subquery의 결과 중 하나 이상 동일하면 참, ‘&lt; ANY’(하나라도 크게되면 참), ‘&gt; ANY’(하나라도 작게 되면 참)</li>
  <li>EXISTS(Subquery) : Main query와 Subquery의 결과가 하나라도 존재하면 참이됨</li>
</ul>

<h3 id="1-in">(1) IN</h3>
<ul>
  <li>IN은 반환되는 여러개의 행 중에서 하나만 참이 되어도 되는 연산</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 급여(SAL)가 2000원 이상인 사원번호를 조회한 후에 EMP, EMPNO를 조회</span>
<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">DNAME</span><span class="p">,</span> <span class="n">SAL</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">,</span> <span class="n">DEPT</span>
<span class="k">WHERE</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span><span class="o">=</span><span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span>
<span class="k">AND</span> <span class="n">EMP</span><span class="p">.</span><span class="n">EMPNO</span>
<span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">EMPNO</span> <span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">WHERE</span> <span class="n">SAL</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="2-all">(2) ALL</h3>
<ul>
  <li>메인쿼리와 서브쿼리의 결과가 모두 동일하면 참이 됨</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- DEPTNO가 20, 30보다 작거나 같은 것을 조회</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">WHERE</span> <span class="n">DEPTNO</span> <span class="o">&lt;=</span> <span class="k">ALL</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="3-exists">(3) EXISTS</h3>
<ul>
  <li>EXISTS는 Subquery로 어떤 데이터 존재 여부를 확인하는 것</li>
  <li>즉 EXISTS의 결과는 참과 거짓이 반환됨</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 급여가 2000 이상이 있으면 참이 반환되고 없으면 거짓이 반환됨</span>
<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">DNAME</span><span class="p">,</span> <span class="n">SAL</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">,</span> <span class="n">DEMT</span>
<span class="k">WHERE</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span><span class="o">=</span><span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span>
<span class="k">AND</span> <span class="n">EXSITS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">SAL</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="4-스칼라scala-subquery">4. 스칼라(Scala) Subquery</h2>
<ul>
  <li>스칼라 Subquery는 반드시 한 행과 한 칼럼만 반환하는 서브쿼리임</li>
  <li>만약 여러 행이 반환되면 오류가 발생</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ENAME</span> <span class="k">AS</span> <span class="s1">'이름'</span>
<span class="n">SAL</span> <span class="k">AS</span> <span class="s1">'급여'</span>
<span class="c1">--  스칼라 서브쿼리, 한개의 행만 조회되어야 함</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="k">AVG</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">)</span> <span class="k">AS</span> <span class="s1">'평균급여'</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">WHERE</span> <span class="n">EMPNO</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>위의 예처럼 직원 급여를 조회할 때 평균 급여를 같이 계산하여 조회하게 함</li>
  <li>스칼라 (Subquery)를 사용해서 직원의 평균 급여를 계산한 것</li>
</ul>

<h2 id="6-연관correlated-subquery">6. 연관(Correlated) Subquery</h2>
<ul>
  <li>연관 Subquery는 Subquery 내에서 Main Query 내의 칼럼을 사용하는 것을 의미</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span> <span class="n">EMP</span> <span class="n">a</span>
<span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">DEPT</span> <span class="n">b</span>
<span class="k">WHERE</span> <span class="n">b</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">DEPTNO</span><span class="p">);</span>
<span class="c1">-- Main query에서 데이터를 받아서 Subquery를 실행함</span>
</code></pre></div></div>

<h1 id="point-4-그룹-함수group-function"><a href="">POINT 4. 그룹 함수(Group Function)</a></h1>
<h2 id="1-rollup">1. ROLLUP</h2>
<ul>
  <li>ROLLUP은 GROUP BY의 컬럼에 대해서 Subtotal을 만들어 줌</li>
  <li>ROLLUP을 할 때 GROUP BY구에 칼럼이 두 개 이상 오면 순서에 따라서 결과가 달라짐</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- DEPTNO가 NULL이면 '전체합계' 문자를 출력</span>
<span class="k">SELECT</span> <span class="n">DECODE</span> <span class="p">(</span><span class="n">DEPTNO</span><span class="p">,</span> <span class="k">NULL</span><span class="p">,</span> <span class="s1">'전체합계'</span><span class="p">,</span> <span class="n">DEPTNO</span><span class="p">),</span> <span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">ROLLUP</span><span class="p">(</span><span class="n">DEPTNO</span><span class="p">);</span>
<span class="c1">-- ROLLUP을 사용하면 부서별 합계 및 전체합계가 계산</span>
</code></pre></div></div>

<ul>
  <li>
    <p>위의 예는 DEPTNO에 대해서 GROUP BY로 급여합계를 계산하고 부서별 전체합계를 추가해서 계산, 즉, ROLLUP은 DEPTNO에 대해서 기존 GROUP BY와는 다르게 부서별 전체합계를 계산하게 됨</p>
  </li>
  <li>
    <p>DECODE문은 전체합계를 조회할 때 ‘전체합계’라는 문자를 출력하기 위해서 사용, DECODE문을 사용해서 DEPTNO가 NULL과 같으면 ‘전체합계’라는 문자를 출력하고 그렇지 않으면 부서번호(DEPTNO)를 출력</p>
  </li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="n">JOB</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">ROLLUP</span><span class="p">(</span><span class="n">DEPTNO</span><span class="p">,</span> <span class="n">JOB</span><span class="p">);</span>
<span class="c1">-- 부서별, 직업별 합계를 구함</span>
<span class="c1">-- ROLLUP은 subtotal을 구함</span>
</code></pre></div></div>

<ul>
  <li>부서별, 직업별 ROLLUP을 실행하면 부서별 합계, 직업별 합계, 전체 합계가 모두 조회됨</li>
  <li>ROLLUP으로 실행되는 칼럼별로 Subtotal을 만들어 줌</li>
</ul>

<h2 id="2-grouping-함수">2. GROUPING 함수</h2>
<ul>
  <li>GROUPINT 함수는 ROLLUP, CUBE, GROUPING SETS에서 생성되는 합계 값을 구분하기 위해서 만들어진 함수</li>
  <li>예를 들어 소계, 합계 등이 계산되면 GROUPING 함수는 1을 반환하고 그렇지 않으면 0을 반환해서 합계 값을 식별할 수 있음</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- ROLLUP, CUBE, GROUPING SETS으로 계산된 합계는 '1' 아니면 '0'으로 표시</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="k">GROUPING</span><span class="p">(</span><span class="n">DEPTNO</span><span class="p">),</span>
<span class="n">JOB</span><span class="p">,</span> <span class="k">GROUPING</span><span class="p">(</span><span class="n">JOB</span><span class="p">),</span> <span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">ROLLUP</span><span class="p">(</span><span class="n">DEPTNO</span><span class="p">);</span>
<span class="c1">-- '1'의 값으로 소계와 전체합계를 개발자가 구분할 수 있게 됨</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- DECODE를 사용해서 전체합계와 부서합계를 구분</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span>
<span class="n">DECODE</span><span class="p">(</span><span class="k">GROUPING</span><span class="p">(</span><span class="n">DEPTNO</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'전체합계'</span><span class="p">)</span> <span class="n">TOT</span><span class="p">,</span>
<span class="n">JOB</span><span class="p">,</span>
<span class="n">DECODE</span><span class="p">(</span><span class="k">GROUPING</span><span class="p">(</span><span class="n">JOB</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'부서합계'</span><span class="p">)</span> <span class="n">T_DEPT</span><span class="p">,</span>
<span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">ROLLUP</span><span class="p">(</span><span class="n">DEPTNO</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>위의 예를 보면 DECODE 함수를 사용해서 전체 합계와 부서합계를 구분</li>
  <li>GROUPING 함수의 기능을 사용하면 사용자가 필요로 하는 데이터를 SELECT문으로 작성하여 제공할 수 있음</li>
</ul>

<h2 id="3-grouping-sets-함수">3. GROUPING SETS 함수</h2>
<ul>
  <li>GROUPING SETS 함수는 GROUP BY에 나오는 칼럼의 순서와 관계없이 다양한 소계를 만들 수 있음</li>
  <li>GROUPING SETS 함수는 GROUP BY에 나오는 칼럼의 순서와 관계없이 개별적으로 모두 처리</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="n">JOB</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">GROUPING</span> <span class="k">SETS</span> <span class="p">(</span><span class="n">DEPTNO</span><span class="p">,</span> <span class="n">JOB</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>위의 예를 보면 GROUPING SETS 함수로 DEPTNO와 JOB을 실행</li>
  <li>그 결과 DEPTNO 합계가 개별적으로 조회</li>
</ul>

<h2 id="4-cube-함수">4. CUBE 함수</h2>
<ul>
  <li>CUBE는 CUBE 함수에 제시한 칼럼에 대해서 결합 가능한 모든 집계를 계산</li>
  <li>다차원 집계를 제공하여 다양하게 데이터를 분석할 수 있게 함</li>
  <li>예를 들어 부서와 직업을 CUBE로 사용하면 부서별 합계, 직업별 합계, 부서별 직업별 합계, 전체 합계가 조회</li>
  <li>즉, 조합할 수 있는 경우의 소가 모두 조합되는 것임</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="n">JOB</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">CUBE</span><span class="p">(</span><span class="n">DEPTNO</span><span class="p">,</span> <span class="n">JOB</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>
<h1 id="point-5-윈도우-함수window-function"><a href="">POINT 5. 윈도우 함수(Window Function)</a></h1>
<h2 id="1-윈도우-함수">1. 윈도우 함수</h2>
<ul>
  <li>윈도우 함수는 행과 행간의 관계를 정의 하기 위해서 제공되는 함수</li>
  <li>윈도우 함수를 사용해서 순위, 합계, 평균, 행 위치 등을 조작 가능</li>
</ul>

<h3 id="윈도우-함수-구조">윈도우 함수 구조</h3>
<ul>
  <li>ARGUMENTS(인수) : 윈도우 함수에 따라서 0~N개의 인수를 설정함</li>
  <li>PARTITION BY : 전체 집합을 기준에 의해 소그룹으로 나눔</li>
  <li>ORDER BY : 어떤 항목에 대해서 정렬</li>
  <li>WINDOWING : 행 기준의 범위를 정함, ROWS는 물리적 결과의 행 수이고 RANGE는 논리적인 값에 의한 범위</li>
</ul>

<h3 id="windowing">WINDOWING</h3>
<ul>
  <li>ROWS : 부분집합인 윈도우 크기를 물리적 단위로 행의 집합을 지정함</li>
  <li>RANGE : 논리적인 주소에 의해 행 집합을 지정</li>
  <li>BETWEEN~AND : 윈도우의 시작과 끝의 위치를 지정</li>
  <li>UNBOUNDED PRECEDING : 윈도우의 시작 위치가 첫 번째 행임을 의미</li>
  <li>UNBOUNDED FOLLOWING : 윈도우 마지막 위치가 마지막 행임을 의미</li>
  <li>CURRENT ROW : 윈도우 시작 위치가 현재 행임을 의미</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">EMPNO</span><span class="p">,</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span>
  <span class="c1">-- 첫번째 행을 의미</span>
<span class="k">ROW</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span>
<span class="c1">-- 마지막 행을 의미</span>
<span class="k">AND</span> <span class="n">UNBOUNDED</span> <span class="k">FOLLOWING</span><span class="p">)</span> <span class="n">TOTSAL</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>UNBOUNDED PRECEDING은 처음 행을 의미하며, UNBOUNDED FOLLING은 마지막 행을 의미, 그러므로 TOTSAL에 처음부터 마지막까지의 합계(SUM(SAL))을 계산한 것</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 처음부터 CURRENT ROW까지의 합계를 계산, 결과적으로 누적합계가 됨</span>
<span class="k">SELECT</span> <span class="n">EMPNO</span><span class="p">,</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span>
<span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span>
<span class="k">AND</span> <span class="k">CURRENT</span> <span class="k">ROW</span><span class="p">)</span> <span class="n">TOTSAL</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>첫 번째 행의 SAL은 800이고 두 번째 행의 SAL은 950임, 그러므로 두번 째 행의 TOTSAL은 800+950=1750임, 계속 누적해서 더해 나감</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">EMPTNO</span><span class="p">,</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span>
<span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="n">OVER</span><span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span>
<span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="k">CURRENT</span> <span class="k">ROW</span>
<span class="k">AND</span> <span class="n">UNBOUNDED</span> <span class="k">FOLLOWING</span><span class="p">)</span> <span class="n">TOTSAL</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>CURRENT ROW부터 마지막행(UNBOUNDED FOLLOWING)까지의 합계를 계산</li>
  <li>첫 번째 행의 SAL이 800이므로 800부터 끝까지의 합계를 TOTSAL에 계산 결과적을 전체 합계가 됨</li>
</ul>

<h2 id="2-순위-함수rank-function">2. 순위 함수(RANK Function)</h2>
<ul>
  <li>윈도우 함수는 특정 항목과 파티션에 대해서 순위를 계산할 수 있는 함수를 제공</li>
  <li>순위 함수는 RANK, DENSE_RANK, ROW_NUMBER 함수가 있음</li>
</ul>

<h3 id="순위rank-관련-윈도우-함수">순위(RANK) 관련 윈도우 함수</h3>
<ul>
  <li>RANK : 특정항목 및 파티션에 대해서 순위를 계산</li>
  <li>DENSE_RANK : 동일한 순위를 하나의 건수로 계산</li>
  <li>ROW_NUMBER : 동일한 순위에 대해서 고유의 순위를 부여</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ENMAE</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="n">RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span><span class="p">)</span> <span class="n">ALL_RANK</span><span class="p">,</span>
<span class="n">RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">JOB</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span><span class="p">)</span> <span class="n">JOB_RANK</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>RANK 함수는 순위를 계산하며, 동일한 순위에게는 같은 순위가 부여</li>
  <li>RANK() OVER (ORDER BY SAL DESC)는 SAL로 등수를 계산하고 내림차순으로 조회하게 함</li>
  <li>RANK() OVER (PARTITION BY JOB ORER BY SAL DESC)는 JOB으로 파티션을 만들고 JOB별 순위를 조회하게 함</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="n">RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span><span class="p">)</span> <span class="n">ALL_RANK</span><span class="p">,</span>
<span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span><span class="p">)</span> <span class="n">DENSE_RANK</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>동일한 순위를 하나의 건수로 계산</li>
  <li>2등이 2명이면 3등이 없지만, DENSE_RANK()는 건수로 인식하기 때문에 3등이 있게 됨</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="n">RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span><span class="p">)</span> <span class="k">ALL</span> <span class="n">RANK</span><span class="p">,</span>
<span class="n">ROW_NUMBER</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="n">OERDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span><span class="p">)</span> <span class="n">ROW_NUM</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<p>– ROW_NUMBER 함수는 동일한 순위에 대해서 고유의 순위를 부여</p>

<h2 id="3-집계함수rank-function">3. 집계함수(RANK function)</h2>
<ul>
  <li>윈도우 함수를 제공</li>
</ul>

<h3 id="집계aggregate-관련-윈도우-함수">집계(AGGREGATE) 관련 윈도우 함수</h3>
<ul>
  <li>SUM : 파티션 별로 합계를 계산</li>
  <li>AVG : 파티션 별로 평균을 계산</li>
  <li>COUNT : 파티션 별로 행 수를 계산</li>
  <li>MAX와 MIN : 파티션 별로 최대값과 최소값을 계산</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 같은 관리자(MGR)에 파티션을 만들고 합계(SUM)을 계산</span>
<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">MGR</span><span class="p">)</span> <span class="n">SUM_MGR</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="4-행-순서-관련-함수">4. 행 순서 관련 함수</h2>
<ul>
  <li>행 순서 관련 함수는 상위 행의 값을 하위에 출력하거나 하위 행의 값을 상위 행에 출력하게 할 수 있음</li>
  <li>특정 위치의 행을 가지고 와서 출력할 수 있음</li>
</ul>

<h3 id="행-순서-관련-윈도우-함수">행 순서 관련 윈도우 함수</h3>
<ul>
  <li>FIRST_VALUE : 파티션에서 가장 처음에 나오는 값을 구함, MIN 함수를 사용해서 같은 결과를 구할 수 있음</li>
  <li>LAST_VALUE : 파티션에서 가장 나중에 나오는 값을 구함, MAX 함수를 사용해서 같은 결과를 구할 수 있음</li>
  <li>LAG : 이전 행을 가지고 옴</li>
  <li>LEAD : 윈도우에서 특정 위치의 행을 가지고 옴, 기본값은 1</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="n">FIRST_VALUE</span><span class="p">(</span><span class="n">ENAME</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">DEPTNO</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span> <span class="k">ROWS</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span><span class="p">)</span> <span class="k">AS</span> <span class="n">DEPT_A</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>FIRST_VALUE 함수는 파티션에서 조회된 행 중에서 첫 번째 행의 값을 가지고 옴</li>
  <li>위의 예에서 TEST7과 TEST14가 조회됨, 그 중에서 TEST7이 첫 번째 힝이므로 첫 번째 행의 TEST7을 가지고 옴</li>
  <li>단, SAL 내림차순으로 조회했기 때문에 의미 상으로는 부서 내에 가장 급여가 많은 사원이 됨</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="c1">-- 마지막 행을 가져옴</span>
<span class="n">LAST_VALUE</span><span class="p">(</span><span class="n">ENAME</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">DEPTNO</span>
<span class="c1">-- 부서 내에서 급여가 가장 적은 사람을 가져옴</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span> <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="k">CURRENT</span> <span class="k">ROW</span> <span class="k">AND</span> <span class="n">UNBOUNDED</span> <span class="k">FOLLOWING</span><span class="p">)</span> <span class="k">AS</span> <span class="n">DEPT_A</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="5-비율-관련-함수">5. 비율 관련 함수</h2>
<ul>
  <li>비율 관련 함수는 누적 백분율, 순서별 백분율, 파티션을 N분으로 분할한 결과 등을 조회할 수 있음</li>
</ul>

<h3 id="비율-관련-윈도우-함수">비율 관련 윈도우 함수</h3>
<ul>
  <li>CUME_DIST : 파티션 전체 건수에서 현재 행보다 작거나 같은 건수에 대한 누적 백분율을 조회 함, 누적 분포상에 위치를 0~1 사이의 값을 가짐</li>
  <li>PERCENT_RANK : 파티션에서 제일 먼저 나온 것을 0으로 제일 늦게 나온 것을 1로 하여 값이 아닌 행의 순서별 백분율을 조회</li>
  <li>NTILE : 파티션별로 전체 건수를 ARGUMENT 값으로 N 등분한 결과를 조회</li>
  <li>RATIO_TO_REPORT : 파티션 내의 전체 SUM(칼럼)에 대한 행 별 칼럼 값의 백분율을 소수점까지 조회함</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="n">PERCENT_RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">DEPTNO</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span><span class="p">)</span> <span class="k">AS</span> <span class="n">PERCENT_SAL</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>PERCENT_RANK 함수는 파티션에서 등수의 퍼센트를 구하는 것</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="n">ENAME</span><span class="p">,</span> <span class="n">SAL</span><span class="p">,</span>
<span class="c1">-- 4개로 등분하여 분류</span>
<span class="n">NTILE</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">SAL</span> <span class="k">DESC</span><span class="p">)</span> <span class="k">AS</span> <span class="n">N_TILE</span>
<span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>NTILE(4)는 4개로 분할하라는 의미로 위의 예제에서는 급여가 높은 순으로 1~4등분으로 분할함</li>
</ul>

<h1 id="point-6-테이블-파티션table-partition">POINT 6. 테이블 파티션(Table Partition)</h1>
<h2 id="1-partition-기능">1. Partition 기능</h2>
<ul>
  <li>파티션은 대용량의 테이블을 여러 개의 데이터 파일에 분리해서 저장하게 함</li>
  <li>테이블의 데이터가 물리적으로 분리된 데이터 파일에 저장되면 입력, 수정, 삭제, 조회 성능이 향상됨</li>
  <li>파티션을 각각의 파티션 별로 독립적으로 관리될 수 있음. 즉, 파티션 별로 백업하고 복구가 가능하면 파티션 전용 인덱스 생성도 가능.</li>
  <li>파티션은 Oracle 데이터베이스의 논리적 관리 단위인 테이블 스페이스 간에 이동이 가능</li>
  <li>데이터를 조회할 때 데이터의 범위를 줄여서 성능을 향상시킴</li>
</ul>

<h2 id="2-range-partiton">2. Range Partiton</h2>
<ul>
  <li>Range Partitiondms 테이블의 칼럼 중에서 값의 범위를 기준으로 여러 개의 파티션으로 데이터를 나누어 저장하는 것</li>
</ul>

<h2 id="3-list-partition">3. List Partition</h2>
<ul>
  <li>List Partition은 특정 값을 기준으로 분할하는 방법</li>
  <li>예를들어 DEPTNO가 10번인 것은 Datafile1.dbf에 저장하고 20번인 것은 Datafile2.dbf에 저장</li>
</ul>

<h2 id="4-hash-partition">4. Hash Partition</h2>
<ul>
  <li>Hash Partition은 데이터베이스 관리 시스템이 내부적으로 해시함수를 사용해서 데이터를 분할</li>
  <li>결과적으로 데이터베이스 관리 시스템이 알아서 분할하고 관리하는 것</li>
  <li>Hash Prtition 이외에도 Composite Partition이 있는데, Composite Partition은 여러개의 파티션 기법을 조합해서 사용하는 것</li>
</ul>

<h2 id="5-파티션-인덱스">5. 파티션 인덱스</h2>
<ul>
  <li>파티션 인덱스는 4가지 유형의 인덱스를 제공, 즉, 파티션 키를 사용해서 인덱스를 만드는 Prefixed Index와 해당 파티션만 사용하는 Local Index 등으로 나누어짐</li>
  <li>Oracle 데이터베이스는 Global Non-Prefixed를 지원하지 않음</li>
</ul>

<h3 id="파티션-인덱스partition-index">파티션 인덱스(Partition Index)</h3>
<ul>
  <li>Global Index : 여러개의 파티션에서 하나의 인덱스를 사용</li>
  <li>Local Index : 해당 파티션 별로 각자의 인덱스를 사용</li>
  <li>Prefixed Index : 파티션 키와 인덱스 키가 동일함</li>
  <li>Non Prefixed Index : 파티션 키와 인덱스키가 다름</li>
</ul>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="safenumz/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/sql/2019/03/10/SQLD_02)_SQL_%ED%99%9C%EC%9A%A9.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>AI and Data Engineering</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/fastai" target="_blank" title="fastai"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/fastdotai" target="_blank" title="fastdotai"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
